const { ActionRowBuilder, ButtonBuilder, ButtonStyle, AttachmentBuilder, StringSelectMenuBuilder } = require('discord.js');
const { CONFIG } = require('../config');
const store = require('../data/store');
const { renderChartToBuffer } = require('../utils/renderChart');

const STATS_DEFAULT_TIMEFRAME_KEY = CONFIG.stats.defaultTimeframeKey;
const STATS_TIMEFRAMES = CONFIG.stats.timeframes;

const GAMES = CONFIG.stats.games;
const THEORETICAL_WIN_CHANCE = CONFIG.stats.theoreticalWinChance;

function downsampleSeries(points, maxPoints = 180) {
  if (points.length <= maxPoints) return points;
  const step = Math.ceil(points.length / maxPoints);
  const sampled = [];
  for (let i = 0; i < points.length; i += step) sampled.push(points[i]);
  const last = points[points.length - 1];
  if (sampled[sampled.length - 1] !== last) sampled.push(last);
  return sampled;
}

function formatClock(ts) {
  const d = new Date(ts);
  const hh = String(d.getHours()).padStart(2, '0');
  const mm = String(d.getMinutes()).padStart(2, '0');
  return `${hh}:${mm}`;
}


function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// parse a custom id generated by getNavRow (buttons) or other stats-related
// components.  The button ids are always of the form
//   stats_<page>_<viewerId>_<targetId>[_<timeframeKey>]
// where <page> is one of the keys returned by getNavRow.  We intentionally
// *do not* try to interpret the `stats_tf_...` select‚Äëmenu id here because that
// component is handled separately in handleStatsSelectMenu.  Keeping the
// parsing simple makes the logic easier to reason about and eliminates the
// previous special‚Äëcase that incorrectly mapped "tf" back to "networth".
function parseStatsCustomId(customId) {
  const parts = customId.split('_');
  if (parts.length < 4) return null;
  const page = parts[1];
  const viewerId = parts[2];
  const targetId = parts[3];
  const timeframeKey = parts[4] || STATS_DEFAULT_TIMEFRAME_KEY;
  if (!page || !viewerId || !targetId) return null;
  return { page, viewerId, targetId, timeframeKey };
}

function getStatsTimeframeByKey(timeframeKey) {
  return STATS_TIMEFRAMES.find((entry) => entry.key === timeframeKey) || STATS_TIMEFRAMES.find((entry) => entry.key === STATS_DEFAULT_TIMEFRAME_KEY);
}

function getNavRow(viewerId, targetId, activePage, timeframeKey) {
  const pages = [
    { key: 'networth', label: 'Networth' },
    { key: 'finance', label: 'Finance' },
    { key: 'winloss', label: 'Win Loss' },
    { key: 'topbets', label: 'Top Bets' },
    { key: 'xp', label: 'XP' },
    { key: 'collectibles', label: 'Collection' },
  ];
  const rows = [];
  for (let i = 0; i < pages.length; i += 5) {
    const row = new ActionRowBuilder();
    for (const page of pages.slice(i, i + 5)) {
      row.addComponents(
        new ButtonBuilder()
          .setCustomId(`stats_${page.key}_${viewerId}_${targetId}_${timeframeKey}`)
          .setLabel(page.label)
          .setStyle(page.key === activePage ? ButtonStyle.Primary : ButtonStyle.Secondary)
      );
    }
    rows.push(row);
  }
  return rows;
}

// when rendering the timeframe menu we include the currently active page in
// the custom id.  this allows handleStatsSelectMenu to know which page the
// menu applies to without having to inspect the embed title (which is brittle).
function getTimeframeRow(viewerId, targetId, activePage, activeTimeframeKey) {
  const menu = new StringSelectMenuBuilder()
    .setCustomId(`stats_tf_${viewerId}_${targetId}_${activePage}`)
    .setPlaceholder('Select timeframe')
    .addOptions(STATS_TIMEFRAMES.map(tf => ({
      label: tf.label,
      value: tf.key,
      default: tf.key === activeTimeframeKey,
    })));
  return new ActionRowBuilder().addComponents(menu);
}

function getStatsComponents(viewerId, targetId, activePage, timeframeKey) {
  let rows = [];
  const navRows = getNavRow(viewerId, targetId, activePage, timeframeKey);
  if (Array.isArray(navRows)) rows = rows.concat(navRows);
  else rows.push(navRows);
  if (activePage === 'networth' || activePage === 'xp' || activePage === 'collectibles') {
    rows.push(getTimeframeRow(viewerId, targetId, activePage, timeframeKey));
  }
  return rows;
}

async function resolveTargetFromOptions(interaction) {
  const targetUser = interaction.options.getUser('user');

  let userId = interaction.user.id;
  let username = interaction.user.username;

  if (targetUser) {
    userId = targetUser.id;
    username = targetUser.username;
  }

  if (!store.hasWallet(userId)) {
    return null;
  }

  return { userId, username };
}

function renderOverview(username, wallet) {
  const stats = wallet.stats;
  const currentTotalBalance = (wallet.balance || 0) + (wallet.bank || 0);
  const totalGames = GAMES.reduce((sum, g) => sum + ((stats[g] || {}).wins || 0) + ((stats[g] || {}).losses || 0), 0);
  const totalWins = GAMES.reduce((sum, g) => sum + ((stats[g] || {}).wins || 0), 0);
  const overallWinRate = totalGames > 0 ? ((totalWins / totalGames) * 100).toFixed(1) : '0.0';
  const netProfit = (stats.lifetimeEarnings || 0) - (stats.lifetimeLosses || 0);

  const topGames = GAMES
    .map((game) => {
      const gs = stats[game] || { wins: 0, losses: 0 };
      const plays = gs.wins + gs.losses;
      return { game, plays, wins: gs.wins, losses: gs.losses };
    })
    .sort((a, b) => b.plays - a.plays)
    .slice(0, 3);

  let topGamesText = '';
  for (const item of topGames) {
    if (item.plays === 0) continue;
    const wr = ((item.wins / item.plays) * 100).toFixed(1);
    topGamesText += `> **${capitalize(item.game)}**: ${item.wins}W / ${item.losses}L (${wr}%)\n`;
  }
  if (!topGamesText) topGamesText = '> No game history yet\n';

  // build income/spending breakdown by activity
  let breakdownText = '';
  for (const g of GAMES) {
    const gs = stats[g] || {};
    const earn = gs.earnings || 0;
    const lostAmt = gs.lossesAmount || 0;
    if (earn || lostAmt) {
      breakdownText += `> **${capitalize(g)}**: +${store.formatNumber(earn)} / -${store.formatNumber(lostAmt)}\n`;
    }
  }
  // other income sources
  if (stats.interest && stats.interest.totalEarned) breakdownText += `> **Interest**: +${store.formatNumber(stats.interest.totalEarned)}\n`;
  if (stats.universalIncome && stats.universalIncome.totalEarned) breakdownText += `> **Universal Income**: +${store.formatNumber(stats.universalIncome.totalEarned)}\n`;
  if (stats.dailySpin && stats.dailySpin.amountWon) breakdownText += `> **Daily Spin**: +${store.formatNumber(stats.dailySpin.amountWon)}\n`;
  if (stats.giveaway) {
    if (stats.giveaway.amountWon) breakdownText += `> **Giveaway Wins**: +${store.formatNumber(stats.giveaway.amountWon)}\n`;
    if (stats.giveaway.amountGiven) breakdownText += `> **Giveaway Given**: -${store.formatNumber(stats.giveaway.amountGiven)}\n`;
  }
  if (stats.mysteryBox) {
    if (stats.mysteryBox.spent) breakdownText += `> **Mystery Box Spent**: -${store.formatNumber(stats.mysteryBox.spent)}\n`;
    if (stats.mysteryBox.duplicateCompEarned) breakdownText += `> **Mystery Dupes**: +${store.formatNumber(stats.mysteryBox.duplicateCompEarned)}\n`;
  }
  if (!breakdownText) breakdownText = '> No income/spending recorded yet\n';

  return {
    title: `‚óà ${username}'s Stats`,
    color: 0x2b2d31,
    fields: [
      {
        name: '‚óâ Economy Snapshot',
        value: `> Purse: **${store.formatNumber(wallet.balance || 0)}**\n> Bank: **${store.formatNumber(wallet.bank || 0)}**\n> Net Worth: **${store.formatNumber(currentTotalBalance)}**`,
        inline: true,
      },
      {
        name: '‚ñ≤ Lifetime Summary',
        value: `> Earnings: **${store.formatNumber(stats.lifetimeEarnings || 0)}**\n> Losses: **${store.formatNumber(stats.lifetimeLosses || 0)}**\n> Net: **${netProfit >= 0 ? '+' : ''}${store.formatNumber(netProfit)}**\n> Win Rate: **${overallWinRate}%** (${totalWins}/${totalGames})`,
        inline: true,
      },
      {
        name: 'üéÅ Mystery Boxes',
        value: `> Opened: **${stats.mysteryBox ? stats.mysteryBox.opened || 0 : 0}**\n> Spent: **${store.formatNumber(stats.mysteryBox ? stats.mysteryBox.spent || 0 : 0)}**\n> Dupe Comp: **${store.formatNumber(stats.mysteryBox ? stats.mysteryBox.duplicateCompEarned || 0 : 0)}**`,
        inline: true,
      },
      {
        name: '‚ñ∏ Most Played',
        value: topGamesText,
        inline: false,
      },
      {
        name: '‚ñ∏ Income / Spending Breakdown',
        value: breakdownText,
        inline: false,
      },
    ],
  };
}

function renderWinLossPage(username, wallet) {
  const stats = wallet.stats;
  const fields = [];

  for (const game of GAMES) {
    const gs = stats[game] || { wins: 0, losses: 0 };
    const plays = gs.wins + gs.losses;
    if (plays === 0) {
      fields.push({ name: capitalize(game), value: '> No plays yet', inline: true });
      continue;
    }

    const actual = (gs.wins / plays) * 100;
    const expected = THEORETICAL_WIN_CHANCE[game] == null ? null : (THEORETICAL_WIN_CHANCE[game] * 100);
    const deltaVal = expected == null ? null : actual - expected;
    const deltaIcon = deltaVal == null ? '' : (deltaVal >= 0 ? '‚ñ≤' : '‚ñº');
    const deltaText = deltaVal == null ? 'n/a' : `${deltaVal >= 0 ? '+' : ''}${deltaVal.toFixed(1)}%`;
    const expectedText = expected == null ? 'n/a' : `${expected.toFixed(1)}%`;

    fields.push({
      name: `${deltaIcon} ${capitalize(game)}`,
      value: `> **${gs.wins}**W / **${gs.losses}**L\n> Actual: **${actual.toFixed(1)}%**\n> Baseline: ${expectedText}\n> Œî **${deltaText}**`,
      inline: true,
    });
  }

  return {
    title: `‚öî ${username}'s Win/Loss`,
    color: 0x2b2d31,
    fields,
  };
}

async function renderNetWorthPage(username, wallet, timeframeKey = STATS_DEFAULT_TIMEFRAME_KEY) {
  const history = Array.isArray(wallet.stats.netWorthHistory) ? wallet.stats.netWorthHistory : [];
  const timeframe = getStatsTimeframeByKey(timeframeKey);

  if (history.length < 2) {
    return {
      content: '',
      embeds: [{
        title: `‚ñ≤ ${username}'s Networth`,
        color: 0x2b2d31,
        description: 'Not enough history yet. Keep playing and this chart will fill in automatically.',
      }],
    };
  }

  const now = Date.now();
  const filteredHistory = timeframe.seconds === null
    ? history
    : history.filter((point) => (point?.t || 0) >= (now - timeframe.seconds * 1000));

  if (filteredHistory.length < 2) {
    return {
      content: '',
      embeds: [{
        title: `‚ñ≤ ${username}'s Networth`,
        color: 0x2b2d31,
        description: `Not enough history in the last ${timeframe.label} yet. Keep playing and this chart will fill in automatically.`,
      }],
    };
  }

  const trimmed = downsampleSeries(filteredHistory, 240);
  const values = trimmed.map((x) => x.v || 0);
  const first = values[0];
  const last = values[values.length - 1];
  const low = Math.min(...values);
  const high = Math.max(...values);
  const delta = last - first;

  const tickEvery = Math.max(1, Math.floor(trimmed.length / 8));
  const labels = trimmed.map((point, i) => (i % tickEvery === 0 || i === trimmed.length - 1) ? formatClock(point.t || now) : '');

  const chartConfig = {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label: `${username} Net Worth`,
        data: values,
        borderColor: '#36a2eb',
        backgroundColor: '#36a2eb',
        borderWidth: 2,
        pointRadius: 0,
        tension: 0.22,
        fill: false,
      }],
    },
    options: {
      plugins: {
        legend: { display: false },
        title: { display: true, text: `Player Networth (${timeframe.label})`, color: '#ffffff' },
      },
      scales: {
        x: { ticks: { color: '#d9d9d9', maxTicksLimit: 8 }, grid: { color: 'rgba(255,255,255,0.08)' } },
        y: { ticks: { color: '#d9d9d9' }, grid: { color: 'rgba(255,255,255,0.08)' } },
      },
      layout: { padding: 8 },
    },
  };
  const chartBuffer = await renderChartToBuffer(chartConfig, 980, 420).catch(() => null);

  const changeIcon = delta >= 0 ? '‚ñ≤' : '‚ñº';
  const networthEmbed = {
    title: `${changeIcon} ${username}'s Networth`,
    color: 0x2b2d31,
    fields: [
      {
        name: '‚óâ Current Balance',
        value: `> Purse: **${store.formatNumber(wallet.balance || 0)}**\n> Bank: **${store.formatNumber(wallet.bank || 0)}**\n> Net Worth: **${store.formatNumber((wallet.balance || 0) + (wallet.bank || 0))}**`,
        inline: true,
      },
      {
        name: `‚óà ${timeframe.label} Overview`,
        value: `> Start: **${store.formatNumber(first)}**\n> Current: **${store.formatNumber(last)}**\n> Change: **${delta >= 0 ? '+' : ''}${store.formatNumber(delta)}**\n> Range: ${store.formatNumber(low)} - ${store.formatNumber(high)}\n> Samples: ${values.length}`,
        inline: true,
      },
    ],
  };

  const result = { content: '', embeds: [networthEmbed] };
  if (chartBuffer) {
    networthEmbed.image = { url: 'attachment://networth.png' };
    result.files = [new AttachmentBuilder(chartBuffer, { name: 'networth.png' })];
  }
  return result;
}



function renderTopBetsPage(username, wallet) {
  const stats = wallet.stats;
  const topWins = Array.isArray(stats.topWins) ? stats.topWins : [];
  const topLosses = Array.isArray(stats.topLosses) ? stats.topLosses : [];

  let winsText = '';
  for (let i = 0; i < topWins.length; i++) {
    const entry = topWins[i];
    const timeStr = entry.t ? `<t:${Math.floor(entry.t / 1000)}:R>` : '';
    winsText += `> **${i + 1}.** ${capitalize(entry.game)}: **+${store.formatNumber(entry.amount)}** ${timeStr}\n`;
  }
  if (!winsText) winsText = '> No wins recorded yet\n';

  let lossesText = '';
  for (let i = 0; i < topLosses.length; i++) {
    const entry = topLosses[i];
    const timeStr = entry.t ? `<t:${Math.floor(entry.t / 1000)}:R>` : '';
    lossesText += `> **${i + 1}.** ${capitalize(entry.game)}: **-${store.formatNumber(entry.amount)}** ${timeStr}\n`;
  }
  if (!lossesText) lossesText = '> No losses recorded yet\n';

  return {
    title: `üèÜ ${username}'s Top Bets`,
    color: 0x2b2d31,
    fields: [
      { name: '‚ñ≤ Biggest Wins', value: winsText, inline: false },
      { name: '‚ñº Biggest Losses', value: lossesText, inline: false },
    ],
  };
}


function renderXpPage(username, userId, wallet) {
  const xp = store.getXpInfo(userId);
  const maxLevel = CONFIG.xp.maxLevel;
  const xpRank = store.getXpRank ? store.getXpRank(userId) : null;

  // 10-parallelogram progress bar for current level progress
  const BAR_TOTAL = 10;
  const filled = xp.xpToNext > 0
    ? Math.floor((xp.currentLevelXp / xp.nextLevelTotal) * BAR_TOTAL)
    : BAR_TOTAL;
  const bar = '‚óÜ'.repeat(Math.min(filled, BAR_TOTAL)) + '‚óá'.repeat(Math.max(0, BAR_TOTAL - filled));

  // 10-parallelogram level bar (one pip per 10 levels)
  const levelPips = Math.floor(xp.level / 10);
  const levelBar = '‚óÜ'.repeat(levelPips) + '‚óá'.repeat(Math.max(0, 10 - levelPips));

  const isMaxLevel = xp.level >= maxLevel;
  const progressText = isMaxLevel
    ? '`MAX LEVEL`'
    : `${bar}  ${store.formatNumber(xp.currentLevelXp)} / ${store.formatNumber(xp.nextLevelTotal)} XP`;

  const bonuses = xp.xpBonuses;
  const bonusLines = [
    `> Bank Interest: **+${(bonuses.interestRate * 100).toFixed(2)}%**`,
    `> Loss Cashback: **+${(bonuses.cashbackRate * 100).toFixed(3)}%**`,
    `> Income Double Chance: **+${(bonuses.universalDoubleChance * 100).toFixed(1)}%**`,
  ].join('\n');

  const baseEmbed = {
    title: `‚≠ê ${username}'s XP`,
    color: 0x2b2d31,
    fields: [
      {
        name: '‚óà Level',
        value: `> **${xp.level}** / ${maxLevel}  ${levelBar}\n> Title: **${xp.title}**`,
        inline: true,
      },
      {
        name: '‚óâ Experience',
        value: `> Total XP: **${store.formatNumber(xp.totalXp)}**\n> Games Played: **${store.formatNumber(xp.totalGamesPlayed)}**\n> XP/Game: **${CONFIG.xp.perGame}**`,
        inline: true,
      },
      {
        name: '‚ñ∏ Level Progress',
        value: `> ${progressText}`,
        inline: false,
      },
      {
        name: '‚ñ≤ Level Bonuses',
        value: bonusLines,
        inline: false,
      },
    ],
  };
  if (xpRank !== null && xpRank !== undefined) {
    baseEmbed.fields.push({ name: 'üèÖ XP Rank', value: `#${xpRank}`, inline: false });
  }
  return baseEmbed;
}

async function renderXpChartPage(username, userId, wallet, timeframeKey = STATS_DEFAULT_TIMEFRAME_KEY) {
  try {
    const xpEmbed = renderXpPage(username, userId, wallet);
    const history = Array.isArray(wallet.stats.xpHistory) ? wallet.stats.xpHistory : [];
    const timeframe = getStatsTimeframeByKey(timeframeKey);

    if (history.length < 2) {
      return { content: '', embeds: [xpEmbed] };
    }

    const now = Date.now();
    const filteredHistory = timeframe.seconds === null
      ? history
      : history.filter((point) => (point?.t || 0) >= (now - timeframe.seconds * 1000));

    if (filteredHistory.length < 2) {
      return { content: '', embeds: [xpEmbed] };
    }

    const trimmed = downsampleSeries(filteredHistory, 240);
    const values = trimmed.map((x) => x.v || 0);
    const tickEvery = Math.max(1, Math.floor(trimmed.length / 8));
    const labels = trimmed.map((point, i) => (i % tickEvery === 0 || i === trimmed.length - 1) ? formatClock(point.t || now) : '');

    const chartConfig = {
      type: 'line',
      data: {
        labels,
        datasets: [{
          label: `${username} XP`,
          data: values,
          borderColor: '#ffd700',
          backgroundColor: '#ffd700',
          borderWidth: 2,
          pointRadius: 0,
          tension: 0.22,
          fill: false,
        }],
      },
      options: {
        plugins: {
          legend: { display: false },
          title: { display: true, text: `XP Progress (${timeframe.label})`, color: '#ffffff' },
        },
        scales: {
          x: { ticks: { color: '#d9d9d9', maxTicksLimit: 8 }, grid: { color: 'rgba(255,255,255,0.08)' } },
          y: { ticks: { color: '#d9d9d9' }, grid: { color: 'rgba(255,255,255,0.08)' } },
        },
        layout: { padding: 8 },
      },
    };
    const chartBuffer = await renderChartToBuffer(chartConfig, 980, 420).catch(() => null);

    const result = { content: '', embeds: [xpEmbed] };
    if (chartBuffer) {
      xpEmbed.image = { url: 'attachment://xp.png' };
      result.files = [new AttachmentBuilder(chartBuffer, { name: 'xp.png' })];
    }
    return result;
  } catch (err) {
    console.error('renderXpChartPage error:', err);
    return { content: '', embeds: [{ title: `‚≠ê ${username}'s XP`, color: 0x2b2d31, description: 'Error rendering XP data.' }] };
  }
}

function renderFinancePage(username, userId, wallet) {
  const stats = wallet.stats || {};
  let breakdownText = '';
  for (const g of GAMES) {
    const gs = stats[g] || {};
    const earn = gs.earnings || 0;
    const lostAmt = gs.lossesAmount || 0;
    if (earn || lostAmt) {
      breakdownText += `> **${capitalize(g)}**: +${store.formatNumber(earn)} / -${store.formatNumber(lostAmt)}\n`;
    }
  }
  if (stats.interest && stats.interest.totalEarned) breakdownText += `> **Interest**: +${store.formatNumber(stats.interest.totalEarned)}\n`;
  if (stats.universalIncome && stats.universalIncome.totalEarned) breakdownText += `> **Universal Income**: +${store.formatNumber(stats.universalIncome.totalEarned)}\n`;
  if (stats.dailySpin && stats.dailySpin.amountWon) breakdownText += `> **Daily Spin**: +${store.formatNumber(stats.dailySpin.amountWon)}\n`;
  if (stats.giveaway) {
    if (stats.giveaway.amountWon) breakdownText += `> **Giveaway Wins**: +${store.formatNumber(stats.giveaway.amountWon)}\n`;
    if (stats.giveaway.amountGiven) breakdownText += `> **Giveaway Given**: -${store.formatNumber(stats.giveaway.amountGiven)}\n`;
  }
  if (stats.mysteryBox) {
    if (stats.mysteryBox.spent) breakdownText += `> **Mystery Box Spent**: -${store.formatNumber(stats.mysteryBox.spent)}\n`;
    if (stats.mysteryBox.duplicateCompEarned) breakdownText += `> **Mystery Dupes**: +${store.formatNumber(stats.mysteryBox.duplicateCompEarned)}\n`;
  }
  if (!breakdownText) breakdownText = '> No income/spending recorded yet\n';

  return {
    title: `üí∞ ${username}'s Finance`,
    color: 0x2b2d31,
    description: '> Breakdown of earnings and losses by activity',
    fields: [
      { name: '‚ñ∏ Income / Spending', value: breakdownText, inline: false },
    ],
  };
}

async function renderCollectiblesPage(username, userId, wallet, timeframeKey = STATS_DEFAULT_TIMEFRAME_KEY) {
  try {
    const uniqueCount = new Set((wallet.inventory || []).map(i => i.id)).size;
    const totalItems = CONFIG.collectibles.totalPlaceholders || 120;
    const history = Array.isArray(wallet.stats.collectibleHistory) ? wallet.stats.collectibleHistory : [];
    const collectRank = store.getCollectibleRank ? store.getCollectibleRank(userId) : null;
    const timeframe = getStatsTimeframeByKey(timeframeKey);

    const collectEmbed = {
      title: `üì¶ ${username}'s Collection`,
      color: 0x2b2d31,
      fields: [
        {
          name: '‚óà Progress',
          value: `> Unique Items: **${uniqueCount}** / ${totalItems}\n> Total Owned: **${(wallet.inventory || []).length}**`,
          inline: true,
        },
        {
          name: '‚óâ Mystery Boxes',
          value: `> Opened: **${wallet.stats.mysteryBox ? wallet.stats.mysteryBox.opened || 0 : 0}**\n> Spent: **${store.formatNumber(wallet.stats.mysteryBox ? wallet.stats.mysteryBox.spent || 0 : 0)}**\n> Dupe Comp: **${store.formatNumber(wallet.stats.mysteryBox ? wallet.stats.mysteryBox.duplicateCompEarned || 0 : 0)}**`,
          inline: true,
        },
      ],
    };
    if (collectRank !== null && collectRank !== undefined) {
      collectEmbed.fields.push({ name: 'üèÖ Collection Rank', value: `#${collectRank}`, inline: false });
    }

    if (history.length < 2) {
      return { content: '', embeds: [collectEmbed] };
    }

    const now = Date.now();
    const filteredHistory = timeframe.seconds === null
      ? history
      : history.filter((point) => (point?.t || 0) >= (now - timeframe.seconds * 1000));

    if (filteredHistory.length < 2) {
      return { content: '', embeds: [collectEmbed] };
    }

    const trimmed = downsampleSeries(filteredHistory, 240);
    const values = trimmed.map((x) => x.v || 0);
    const tickEvery = Math.max(1, Math.floor(trimmed.length / 8));
    const labels = trimmed.map((point, i) => (i % tickEvery === 0 || i === trimmed.length - 1) ? formatClock(point.t || now) : '');

    const chartConfig = {
      type: 'line',
      data: {
        labels,
        datasets: [{
          label: `${username} Collectibles`,
          data: values,
          borderColor: '#9b59b6',
          backgroundColor: '#9b59b6',
          borderWidth: 2,
          pointRadius: 0,
          tension: 0.22,
          fill: false,
        }],
      },
      options: {
        plugins: {
          legend: { display: false },
          title: { display: true, text: `Collection Progress (${timeframe.label})`, color: '#ffffff' },
        },
        scales: {
          x: { ticks: { color: '#d9d9d9', maxTicksLimit: 8 }, grid: { color: 'rgba(255,255,255,0.08)' } },
          y: { ticks: { color: '#d9d9d9' }, grid: { color: 'rgba(255,255,255,0.08)' } },
        },
        layout: { padding: 8 },
      },
    };
    const chartBuffer = await renderChartToBuffer(chartConfig, 980, 420).catch(() => null);

    const result = { content: '', embeds: [collectEmbed] };
    if (chartBuffer) {
      collectEmbed.image = { url: 'attachment://collection.png' };
      result.files = [new AttachmentBuilder(chartBuffer, { name: 'collection.png' })];
    }
    return result;
  } catch (err) {
    console.error('renderCollectiblesPage error:', err);
    return { content: '', embeds: [{ title: `üì¶ ${username}'s Collection`, color: 0x2b2d31, description: 'Error rendering collection data.' }] };
  }
}

async function renderPage(page, username, userId, wallet, timeframeKey = STATS_DEFAULT_TIMEFRAME_KEY) {
  switch (page) {
    case 'finance':
      return { content: '', embeds: [renderFinancePage(username, userId, wallet)] };
    case 'winloss':
      return { content: '', embeds: [renderWinLossPage(username, wallet)] };
    case 'topbets':
      return { content: '', embeds: [renderTopBetsPage(username, wallet)] };
    case 'xp':
      return renderXpChartPage(username, userId, wallet, timeframeKey);
    case 'collectibles':
      return renderCollectiblesPage(username, userId, wallet, timeframeKey);
    case 'networth':
      return renderNetWorthPage(username, wallet, timeframeKey);
    case 'overview':
    default:
      return renderNetWorthPage(username, wallet, timeframeKey);
  }
}

async function handleStats(interaction) {
  try {
    const target = await resolveTargetFromOptions(interaction);

    if (!target) {
      const usernameQuery = interaction.options.getString('username');
      const fallbackName = usernameQuery ? usernameQuery : 'that user';
      return interaction.reply(`No stats found for **${fallbackName}**.`);
    }

    const wallet = store.getWallet(target.userId);
    const rendered = await renderPage('networth', target.username, target.userId, wallet, STATS_DEFAULT_TIMEFRAME_KEY);
    const components = getStatsComponents(interaction.user.id, target.userId, 'networth', STATS_DEFAULT_TIMEFRAME_KEY);
    return interaction.reply({ content: rendered.content, embeds: rendered.embeds, files: rendered.files || [], components });
  } catch (err) {
    console.error('Stats command failed:', err);
    return interaction.reply({ content: 'Something went wrong retrieving stats.', ephemeral: true });
  }
}

async function handleStatsButton(interaction) {
  try {
    const parsed = parseStatsCustomId(interaction.customId);
    if (!parsed) return;

    if (interaction.user.id !== parsed.viewerId) {
      return interaction.reply({ content: 'Open your own /stats panel to interact with buttons.', ephemeral: true });
    }

    if (!store.hasWallet(parsed.targetId)) {
      return interaction.update({ content: 'Stats no longer available for this user.', components: [] });
    }

    const user = await interaction.client.users.fetch(parsed.targetId).catch(() => null);
    const username = user ? user.username : 'Unknown';
    const wallet = store.getWallet(parsed.targetId);
    const page = parsed.page;
    const timeframeKey = getStatsTimeframeByKey(parsed.timeframeKey).key;
    // update with a defer/editReply pattern so files can be attached safely
    await interaction.deferUpdate();
    const rendered = await renderPage(page, username, parsed.targetId, wallet, timeframeKey);
    const components = getStatsComponents(parsed.viewerId, parsed.targetId, page, timeframeKey);
    return interaction.editReply({ content: rendered.content, embeds: rendered.embeds, files: rendered.files || [], components });
  } catch (err) {
    console.error('Stats button handler failed:', err);
    console.error('Interaction context:', {
      customId: interaction.customId,
      userId: interaction.user.id,
      parsed: parsed,
      stack: err && err.stack
    });
    if (!interaction.replied && !interaction.deferred) {
      return interaction.reply({ content: `Something went wrong while updating stats.\nError: ${err && err.message}`, ephemeral: true });
    }
  }
}

async function handleStatsSelectMenu(interaction) {
  try {
    if (!interaction.customId.startsWith('stats_tf_')) return;

    // Format: stats_tf_viewerId_targetId_page
    const parts = interaction.customId.split('_');
    const viewerId = parts[2];
    const targetId = parts[3];
    const activePage = parts[4] || 'networth';

    if (interaction.user.id !== viewerId) {
      return interaction.reply({ content: 'Open your own /stats panel to interact.', ephemeral: true });
    }

    if (!store.hasWallet(targetId)) {
      return interaction.update({ content: 'Stats no longer available for this user.', components: [] });
    }

    const timeframeKey = interaction.values[0];
    const user = await interaction.client.users.fetch(targetId).catch(() => null);
    const username = user ? user.username : 'Unknown';
    const wallet = store.getWallet(targetId);
    const validTimeframeKey = getStatsTimeframeByKey(timeframeKey).key;

    await interaction.deferUpdate();
    const rendered = await renderPage(activePage, username, targetId, wallet, validTimeframeKey);
    const components = getStatsComponents(viewerId, targetId, activePage, validTimeframeKey);
    return interaction.editReply({ content: rendered.content, embeds: rendered.embeds, files: rendered.files || [], components });
  } catch (err) {
    console.error('Stats timeframe menu failed:', err);
    console.error('Interaction context:', {
      customId: interaction.customId,
      userId: interaction.user.id,
      stack: err && err.stack
    });
    if (!interaction.replied && !interaction.deferred) {
      return interaction.reply({ content: `Something went wrong while updating stats.\nError: ${err && err.message}`, ephemeral: true });
    }
  }
}

module.exports = { handleStats, handleStatsButton, handleStatsSelectMenu };
